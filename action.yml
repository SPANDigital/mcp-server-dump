name: 'MCP Server Dump'
description: 'Extract documentation from MCP (Model Context Protocol) servers and output in various formats'
author: 'SPAN Digital'
branding:
  icon: 'file-text'
  color: 'blue'

inputs:
  server-command:
    description: 'MCP server command to execute (e.g., "npx @modelcontextprotocol/server-filesystem /path")'
    required: false
  transport:
    description: 'Transport type (stdio, sse, streamable)'
    required: false
    default: 'stdio'
  endpoint:
    description: 'Endpoint URL for sse or streamable transport'
    required: false
  headers:
    description: 'HTTP headers in Key:Value format (comma-separated for multiple)'
    required: false
  format:
    description: 'Output format (markdown, html, json, pdf)'
    required: false
    default: 'markdown'
  output-file:
    description: 'Output file path (required for pdf format)'
    required: false
  no-toc:
    description: 'Disable table of contents in markdown output'
    required: false
    default: 'false'
  frontmatter:
    description: 'Add frontmatter to output (yaml, toml, json)'
    required: false
  timeout:
    description: 'Connection timeout in seconds'
    required: false
    default: '30'
  verbose:
    description: 'Enable verbose output'
    required: false
    default: 'false'
  context-files:
    description: 'Context configuration files (YAML/JSON) for rich documentation context (comma-separated)'
    required: false

outputs:
  output-file:
    description: 'Path to the generated output file'
  server-info:
    description: 'JSON string containing server capabilities and metadata'

runs:
  using: 'composite'
  steps:
    - name: Run MCP Server Dump
      shell: bash
      run: |
        set -e

        # Function to log messages
        log() {
            echo "::notice::$1"
        }

        # Function to set output
        set_output() {
            echo "$1=$2" >> "$GITHUB_OUTPUT"
        }

        # Function to handle errors
        error_exit() {
            echo "::error::$1"
            exit 1
        }

        log "Starting MCP Server Dump Action"

        # Build the mcp-server-dump command arguments using array for safety
        declare -a CMD_ARGS=()

        # Add transport if specified
        if [ -n "${{ inputs.transport }}" ] && [ "${{ inputs.transport }}" != "stdio" ]; then
            CMD_ARGS+=("-t" "${{ inputs.transport }}")
        fi

        # Add endpoint if specified
        if [ -n "${{ inputs.endpoint }}" ]; then
            CMD_ARGS+=("--endpoint" "${{ inputs.endpoint }}")
        fi

        # Add headers if specified
        if [ -n "${{ inputs.headers }}" ]; then
            # Split headers by comma and add each one
            IFS=',' read -ra HEADER_ARRAY <<< "${{ inputs.headers }}"
            for header in "${HEADER_ARRAY[@]}"; do
                if [ -n "$header" ]; then
                    # Remove leading/trailing whitespace using parameter expansion
                    header="${header#"${header%%[![:space:]]*}"}"
                    header="${header%"${header##*[![:space:]]}"}"
                    CMD_ARGS+=("-H" "$header")
                fi
            done
        fi

        # Add format if not default
        if [ "${{ inputs.format }}" != "markdown" ]; then
            CMD_ARGS+=("-f" "${{ inputs.format }}")
        fi

        # Add output file if specified
        if [ -n "${{ inputs.output-file }}" ]; then
            CMD_ARGS+=("-o" "${{ inputs.output-file }}")
            OUTPUT_FILE="${{ inputs.output-file }}"
        else
            # Generate default output filename based on format
            case "${{ inputs.format }}" in
                "html")
                    OUTPUT_FILE="mcp-server-dump.html"
                    CMD_ARGS+=("-o" "$OUTPUT_FILE")
                    ;;
                "json")
                    OUTPUT_FILE="mcp-server-dump.json"
                    CMD_ARGS+=("-o" "$OUTPUT_FILE")
                    ;;
                "pdf")
                    error_exit "PDF format requires output-file to be specified"
                    ;;
                *)
                    OUTPUT_FILE="mcp-server-dump.md"
                    CMD_ARGS+=("-o" "$OUTPUT_FILE")
                    ;;
            esac
        fi

        # Add no-toc flag if specified
        if [ "${{ inputs.no-toc }}" = "true" ]; then
            CMD_ARGS+=("--no-toc")
        fi

        # Add frontmatter if specified
        if [ -n "${{ inputs.frontmatter }}" ]; then
            CMD_ARGS+=("--frontmatter" "${{ inputs.frontmatter }}")
        fi

        # Add timeout if not default
        if [ "${{ inputs.timeout }}" != "30" ]; then
            CMD_ARGS+=("--timeout" "${{ inputs.timeout }}s")
        fi

        # Add verbose flag if specified
        if [ "${{ inputs.verbose }}" = "true" ]; then
            CMD_ARGS+=("-v")
        fi

        # Add context files if specified
        if [ -n "${{ inputs.context-files }}" ]; then
            # Split context files by comma and add each one
            IFS=',' read -ra CONTEXT_ARRAY <<< "${{ inputs.context-files }}"
            for context_file in "${CONTEXT_ARRAY[@]}"; do
                if [ -n "$context_file" ]; then
                    # Remove leading/trailing whitespace using parameter expansion for portability
                    context_file="${context_file#"${context_file%%[![:space:]]*}"}"
                    context_file="${context_file%"${context_file##*[![:space:]]}"}"

                    # Validate context file exists and is within workspace for security
                    if [ ! -f "$context_file" ]; then
                        log "Warning: Context file '$context_file' not found, skipping"
                        continue
                    fi

                    # Check for path traversal attempts
                    case "$context_file" in
                        *../*|*../|../*|*/..|*/./*|*/./)
                            log "Warning: Context file '$context_file' contains suspicious path, skipping"
                            continue
                            ;;
                    esac

                    CMD_ARGS+=("--context-file" "$context_file")
                fi
            done
        fi

        # Add server command (this should be the last argument)
        if [ -n "${{ inputs.server-command }}" ]; then
            # Split server command into separate arguments for proper handling
            read -ra SERVER_CMD <<< "${{ inputs.server-command }}"
            CMD_ARGS+=("${SERVER_CMD[@]}")
        fi

        # Build complete docker command array
        declare -a DOCKER_CMD_ARRAY=(
            "docker" "run" "--rm"
            "-v" "$PWD:/workspace" "-w" "/workspace"
            "ghcr.io/spandigital/mcp-server-dump:latest"
        )

        # Combine with mcp-server-dump arguments
        FULL_CMD_ARRAY=("${DOCKER_CMD_ARRAY[@]}" "${CMD_ARGS[@]}")

        log "Executing: docker run --rm -v \"$PWD:/workspace\" -w /workspace ghcr.io/spandigital/mcp-server-dump:latest ${CMD_ARGS[*]}"

        # Execute the command using array expansion for safety
        if "${FULL_CMD_ARRAY[@]}"; then
            log "MCP Server Dump completed successfully"
            
            # Set outputs
            set_output "output-file" "$OUTPUT_FILE"
            
            # If the output file exists, try to extract server info for the output
            if [ -f "$OUTPUT_FILE" ] && [ "${{ inputs.format }}" = "json" ]; then
                SERVER_INFO=$(cat "$OUTPUT_FILE")
                set_output "server-info" "$SERVER_INFO"
            elif [ -f "$OUTPUT_FILE" ]; then
                # For non-JSON formats, create a simple server info
                SERVER_INFO="{\"output_file\":\"$OUTPUT_FILE\",\"format\":\"${{ inputs.format }}\"}"
                set_output "server-info" "$SERVER_INFO"
            fi
            
            log "Output file: $OUTPUT_FILE"
        else
            error_exit "MCP Server Dump failed"
        fi