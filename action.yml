name: 'MCP Server Dump'
description: 'Extract documentation from MCP (Model Context Protocol) servers and output in various formats'
author: 'SPAN Digital'
branding:
  icon: 'file-text'
  color: 'blue'

inputs:
  server-command:
    description: 'MCP server command to execute (e.g., "npx @modelcontextprotocol/server-filesystem /path")'
    required: false
  transport:
    description: 'Transport type (stdio, sse, streamable)'
    required: false
    default: 'stdio'
  endpoint:
    description: 'Endpoint URL for sse or streamable transport'
    required: false
  headers:
    description: 'HTTP headers in Key:Value format (comma-separated for multiple)'
    required: false
  format:
    description: 'Output format (markdown, html, json, pdf, hugo)'
    required: false
    default: 'markdown'
  output-file:
    description: 'Output file path (required for pdf format) or directory path (for hugo format)'
    required: false
  no-toc:
    description: 'Disable table of contents in markdown output'
    required: false
    default: 'false'
  frontmatter:
    description: 'Add frontmatter to output (yaml, toml, json)'
    required: false
  timeout:
    description: 'Connection timeout in seconds'
    required: false
    default: '30'
  verbose:
    description: 'Enable verbose output'
    required: false
    default: 'false'
  context-files:
    description: 'Context configuration files (YAML/JSON) for rich documentation context (comma-separated). Use relative paths from workspace root (e.g., "docs/context.yaml,config/overrides.json"). Path traversal attempts are blocked for security.'
    required: false
  scan-tools:
    description: 'Include tools in the documentation output'
    required: false
    default: 'true'
  scan-resources:
    description: 'Include resources in the documentation output'
    required: false
    default: 'true'
  scan-prompts:
    description: 'Include prompts in the documentation output'
    required: false
    default: 'true'
  hugo-base-url:
    description: 'Base URL for Hugo site (e.g., https://example.com or https://docs.mysite.com)'
    required: false
  hugo-language-code:
    description: 'Language code for Hugo site (e.g., en, en-US, zh-Hans, pt-BR)'
    required: false
    default: 'en-us'
  hugo-enterprise-key:
    description: 'Enterprise key for Presidium configuration (optional, uses server name if not specified)'
    required: false
  hugo-theme:
    description: '[DEPRECATED] No longer supported with Presidium layouts. Hugo now uses Presidium modules automatically.'
    required: false
    deprecated: true
  hugo-github:
    description: '[DEPRECATED] No longer supported with Presidium layouts. Configure social links in Hugo site config if needed.'
    required: false
    deprecated: true
  hugo-twitter:
    description: '[DEPRECATED] No longer supported with Presidium layouts. Configure social links in Hugo site config if needed.'
    required: false
    deprecated: true
  hugo-site-logo:
    description: '[DEPRECATED] No longer supported with Presidium layouts. Configure logo in Hugo site config if needed.'
    required: false
    deprecated: true
  hugo-google-analytics:
    description: '[DEPRECATED] No longer supported with Presidium layouts. Configure analytics in Hugo site config if needed.'
    required: false
    deprecated: true
  custom-initialisms:
    description: 'Additional technical initialisms to recognize for human-readable headings (comma-separated, e.g., API,CDN,JWT,CORP,ACME)'
    required: false

outputs:
  output-file:
    description: 'Path to the generated output file'
  server-info:
    description: 'JSON string containing server capabilities and metadata'

runs:
  using: 'composite'
  steps:
    - name: Run MCP Server Dump
      shell: bash
      run: |
        set -e

        # Function to log messages
        log() {
            echo "::notice::$1"
        }

        # Function to set output
        set_output() {
            echo "$1=$2" >> "$GITHUB_OUTPUT"
        }

        # Function to handle errors
        error_exit() {
            echo "::error::$1"
            exit 1
        }

        # Function to parse comma-separated values with whitespace trimming
        # Usage: parse_comma_separated_values "input_string" "item_type" "validation_function" "args..."
        # Sets global array PARSED_ITEMS with trimmed values
        parse_comma_separated_values() {
            local input_string="$1"
            local item_type="$2"
            local validation_function="$3"
            shift 3  # Remove first 3 args, remaining are passed to validation function

            declare -ga PARSED_ITEMS=()

            if [ -n "$input_string" ]; then
                IFS=',' read -ra ITEMS_ARRAY <<< "$input_string"
                for item in "${ITEMS_ARRAY[@]}"; do
                    if [ -n "$item" ]; then
                        # Remove leading/trailing whitespace using parameter expansion for portability
                        item="${item#"${item%%[![:space:]]*}"}"
                        item="${item%"${item##*[![:space:]]}"}"

                        # Skip empty items after trimming
                        if [ -n "$item" ]; then
                            # Apply validation if function provided
                            if [ -n "$validation_function" ] && declare -F "$validation_function" >/dev/null; then
                                if ! "$validation_function" "$item" "$@"; then
                                    # Validation function handles its own logging
                                    continue
                                fi
                            fi

                            PARSED_ITEMS+=("$item")
                        fi
                    fi
                done
            fi
        }

        # Validation function for context files
        validate_context_file() {
            local context_file="$1"

            # Check for path traversal attempts first (most efficient)
            case "$context_file" in
                *../*|*../|../*|*/..|*/./*|*/./)
                    log "Security: Blocked context file '$context_file' (contains path traversal patterns)"
                    return 1
                    ;;
            esac

            # Validate file exists
            if [ ! -f "$context_file" ]; then
                log "File: Context file '$context_file' not found, excluding from documentation"
                return 1
            fi

            return 0
        }

        log "Initializing MCP Server Documentation Extraction"

        # Build the mcp-server-dump command arguments using array for safety
        declare -a CMD_ARGS=()

        # Add transport if specified
        if [ -n "${{ inputs.transport }}" ] && [ "${{ inputs.transport }}" != "stdio" ]; then
            CMD_ARGS+=("-t" "${{ inputs.transport }}")
        fi

        # Add endpoint if specified
        if [ -n "${{ inputs.endpoint }}" ]; then
            CMD_ARGS+=("--endpoint" "${{ inputs.endpoint }}")
        fi

        # Add headers if specified
        if [ -n "${{ inputs.headers }}" ]; then
            parse_comma_separated_values "${{ inputs.headers }}" "header"
            for header in "${PARSED_ITEMS[@]}"; do
                CMD_ARGS+=("-H" "$header")
            done
        fi

        # Add format if not default
        if [ "${{ inputs.format }}" != "markdown" ]; then
            CMD_ARGS+=("-f" "${{ inputs.format }}")
        fi

        # Add output file if specified
        if [ -n "${{ inputs.output-file }}" ]; then
            CMD_ARGS+=("-o" "${{ inputs.output-file }}")
            OUTPUT_FILE="${{ inputs.output-file }}"
        else
            # Generate default output filename based on format
            case "${{ inputs.format }}" in
                "html")
                    OUTPUT_FILE="mcp-server-dump.html"
                    CMD_ARGS+=("-o" "$OUTPUT_FILE")
                    ;;
                "json")
                    OUTPUT_FILE="mcp-server-dump.json"
                    CMD_ARGS+=("-o" "$OUTPUT_FILE")
                    ;;
                "pdf")
                    error_exit "PDF format requires output-file to be specified"
                    ;;
                "hugo")
                    OUTPUT_FILE="hugo-docs"
                    CMD_ARGS+=("-o" "$OUTPUT_FILE")
                    ;;
                *)
                    OUTPUT_FILE="mcp-server-dump.md"
                    CMD_ARGS+=("-o" "$OUTPUT_FILE")
                    ;;
            esac
        fi

        # Add no-toc flag if specified
        if [ "${{ inputs.no-toc }}" = "true" ]; then
            CMD_ARGS+=("--no-toc")
        fi

        # Add frontmatter if specified
        if [ -n "${{ inputs.frontmatter }}" ]; then
            CMD_ARGS+=("--frontmatter" "${{ inputs.frontmatter }}")
        fi

        # Add timeout if not default
        if [ "${{ inputs.timeout }}" != "30" ]; then
            CMD_ARGS+=("--timeout" "${{ inputs.timeout }}s")
        fi

        # Add verbose flag if specified
        if [ "${{ inputs.verbose }}" = "true" ]; then
            CMD_ARGS+=("-v")
        fi

        # Add context files if specified
        if [ -n "${{ inputs.context-files }}" ]; then
            parse_comma_separated_values "${{ inputs.context-files }}" "context file" "validate_context_file"
            for context_file in "${PARSED_ITEMS[@]}"; do
                CMD_ARGS+=("--context-file" "$context_file")
            done
        fi

        # Add scanning control flags if disabled
        if [ "${{ inputs.scan-tools }}" = "false" ]; then
            CMD_ARGS+=("--no-tools")
        fi

        if [ "${{ inputs.scan-resources }}" = "false" ]; then
            CMD_ARGS+=("--no-resources")
        fi

        if [ "${{ inputs.scan-prompts }}" = "false" ]; then
            CMD_ARGS+=("--no-prompts")
        fi

        # Add Hugo-specific configuration if format is hugo
        if [ "${{ inputs.format }}" = "hugo" ]; then
            # Hugo base URL
            HUGO_BASE_URL="${{ inputs.hugo-base-url }}"
            if [ -n "${HUGO_BASE_URL}" ]; then
                CMD_ARGS+=("--hugo-base-url" "${HUGO_BASE_URL}")
            fi

            # Hugo language code (with defensive default handling)
            HUGO_LANG_CODE="${{ inputs.hugo-language-code }}"
            if [ -n "${HUGO_LANG_CODE}" ] && [ "${HUGO_LANG_CODE}" != "en-us" ]; then
                CMD_ARGS+=("--hugo-language-code" "${HUGO_LANG_CODE}")
            fi

            # Hugo enterprise key (optional)
            HUGO_ENTERPRISE_KEY="${{ inputs.hugo-enterprise-key }}"
            if [ -n "${HUGO_ENTERPRISE_KEY}" ]; then
                CMD_ARGS+=("--hugo-enterprise-key" "${HUGO_ENTERPRISE_KEY}")
            fi

            # Deprecated Hugo flags - show warnings but do not pass to command
            HUGO_THEME="${{ inputs.hugo-theme }}"
            if [ -n "${HUGO_THEME}" ]; then
                log "⚠️  WARNING: --hugo-theme is no longer supported. Hugo now uses Presidium layouts via Hugo modules."
            fi

            # Check for other deprecated flags
            HUGO_GITHUB="${{ inputs.hugo-github }}"
            HUGO_TWITTER="${{ inputs.hugo-twitter }}"
            HUGO_SITE_LOGO="${{ inputs.hugo-site-logo }}"
            HUGO_GOOGLE_ANALYTICS="${{ inputs.hugo-google-analytics }}"
            if [ -n "${HUGO_GITHUB}" ] || [ -n "${HUGO_TWITTER}" ] || [ -n "${HUGO_SITE_LOGO}" ] || [ -n "${HUGO_GOOGLE_ANALYTICS}" ]; then
                log "⚠️  WARNING: Social media, logo, and analytics flags are no longer supported for Presidium layouts."
                log "Configure these options directly in your Hugo site config if needed."
            fi
        fi

        # Add custom initialisms if specified (applies to all formats that use human-readable headings)
        CUSTOM_INITIALISMS="${{ inputs.custom-initialisms }}"
        if [ -n "${CUSTOM_INITIALISMS}" ]; then
            parse_comma_separated_values "${CUSTOM_INITIALISMS}" "custom initialism"
            for initialism in "${PARSED_ITEMS[@]}"; do
                CMD_ARGS+=("--custom-initialisms" "${initialism}")
            done
        fi

        # Add server command (this should be the last argument)
        if [ -n "${{ inputs.server-command }}" ]; then
            # Split server command into separate arguments for proper handling
            read -ra SERVER_CMD <<< "${{ inputs.server-command }}"
            CMD_ARGS+=("${SERVER_CMD[@]}")
        fi

        # Build complete docker command array
        declare -a DOCKER_CMD_ARRAY=(
            "docker" "run" "--rm"
            "-v" "$PWD:/workspace" "-w" "/workspace"
            "ghcr.io/spandigital/mcp-server-dump:latest"
        )

        # Combine with mcp-server-dump arguments
        FULL_CMD_ARRAY=("${DOCKER_CMD_ARRAY[@]}" "${CMD_ARGS[@]}")

        log "Executing MCP Server Dump: docker run --rm -v \"$PWD:/workspace\" -w /workspace ghcr.io/spandigital/mcp-server-dump:latest ${CMD_ARGS[*]}"

        # Execute the command using array expansion for safety
        if "${FULL_CMD_ARRAY[@]}"; then
            log "Success: MCP Server documentation extraction completed"

            # Set outputs
            set_output "output-file" "$OUTPUT_FILE"

            # Handle output verification and server info based on format
            if [ "${{ inputs.format }}" = "hugo" ]; then
                # Hugo format creates a directory, not a file
                if [ -d "$OUTPUT_FILE" ]; then
                    SERVER_INFO="{\"output_directory\":\"$OUTPUT_FILE\",\"format\":\"${{ inputs.format }}\"}"
                    set_output "server-info" "$SERVER_INFO"
                    log "Output: Generated Hugo documentation site at directory '$OUTPUT_FILE'"
                else
                    error_exit "Failed: Hugo format should have created directory '$OUTPUT_FILE'"
                fi
            elif [ -f "$OUTPUT_FILE" ] && [ "${{ inputs.format }}" = "json" ]; then
                # JSON format - extract server info from the JSON file
                SERVER_INFO=$(cat "$OUTPUT_FILE")
                set_output "server-info" "$SERVER_INFO"
                log "Output: Generated ${{ inputs.format }} documentation with server metadata at '$OUTPUT_FILE'"
            elif [ -f "$OUTPUT_FILE" ]; then
                # Other file formats (markdown, html, pdf)
                SERVER_INFO="{\"output_file\":\"$OUTPUT_FILE\",\"format\":\"${{ inputs.format }}\"}"
                set_output "server-info" "$SERVER_INFO"
                log "Output: Generated ${{ inputs.format }} documentation at '$OUTPUT_FILE'"
            else
                error_exit "Failed: Expected output was not created"
            fi
        else
            error_exit "Failed: MCP Server documentation extraction encountered an error"
        fi