name: 'MCP Server Dump'
description: 'Extract documentation from MCP (Model Context Protocol) servers and output in various formats'
author: 'SPAN Digital'
branding:
  icon: 'file-text'
  color: 'blue'

inputs:
  server-command:
    description: 'MCP server command to execute (e.g., "npx @modelcontextprotocol/server-filesystem /path")'
    required: false
  transport:
    description: 'Transport type (stdio, sse, streamable)'
    required: false
    default: 'stdio'
  endpoint:
    description: 'Endpoint URL for sse or streamable transport'
    required: false
  headers:
    description: 'HTTP headers in Key:Value format (comma-separated for multiple)'
    required: false
  format:
    description: 'Output format (markdown, html, json, pdf)'
    required: false
    default: 'markdown'
  output-file:
    description: 'Output file path (required for pdf format)'
    required: false
  no-toc:
    description: 'Disable table of contents in markdown output'
    required: false
    default: 'false'
  frontmatter:
    description: 'Add frontmatter to output (yaml, toml, json)'
    required: false
  timeout:
    description: 'Connection timeout in seconds'
    required: false
    default: '30'
  verbose:
    description: 'Enable verbose output'
    required: false
    default: 'false'
  context-files:
    description: 'Context configuration files (YAML/JSON) for rich documentation context (comma-separated). Use relative paths from workspace root (e.g., "docs/context.yaml,config/overrides.json"). Path traversal attempts are blocked for security.'
    required: false

outputs:
  output-file:
    description: 'Path to the generated output file'
  server-info:
    description: 'JSON string containing server capabilities and metadata'

runs:
  using: 'composite'
  steps:
    - name: Run MCP Server Dump
      shell: bash
      run: |
        set -e

        # Function to log messages
        log() {
            echo "::notice::$1"
        }

        # Function to set output
        set_output() {
            echo "$1=$2" >> "$GITHUB_OUTPUT"
        }

        # Function to handle errors
        error_exit() {
            echo "::error::$1"
            exit 1
        }

        # Function to parse comma-separated values with whitespace trimming
        # Usage: parse_comma_separated_values "input_string" "item_type" "validation_function" "args..."
        # Sets global array PARSED_ITEMS with trimmed values
        parse_comma_separated_values() {
            local input_string="$1"
            local item_type="$2"
            local validation_function="$3"
            shift 3  # Remove first 3 args, remaining are passed to validation function

            declare -ga PARSED_ITEMS=()

            if [ -n "$input_string" ]; then
                IFS=',' read -ra ITEMS_ARRAY <<< "$input_string"
                for item in "${ITEMS_ARRAY[@]}"; do
                    if [ -n "$item" ]; then
                        # Remove leading/trailing whitespace using parameter expansion for portability
                        item="${item#"${item%%[![:space:]]*}"}"
                        item="${item%"${item##*[![:space:]]}"}"

                        # Skip empty items after trimming
                        if [ -n "$item" ]; then
                            # Apply validation if function provided
                            if [ -n "$validation_function" ] && declare -F "$validation_function" >/dev/null; then
                                if ! "$validation_function" "$item" "$@"; then
                                    # Validation function handles its own logging
                                    continue
                                fi
                            fi

                            PARSED_ITEMS+=("$item")
                        fi
                    fi
                done
            fi
        }

        # Validation function for context files
        validate_context_file() {
            local context_file="$1"

            # Check for path traversal attempts first (most efficient)
            case "$context_file" in
                *../*|*../|../*|*/..|*/./*|*/./)
                    log "Security: Blocked context file '$context_file' (contains path traversal patterns)"
                    return 1
                    ;;
            esac

            # Validate file exists
            if [ ! -f "$context_file" ]; then
                log "File: Context file '$context_file' not found, excluding from documentation"
                return 1
            fi

            return 0
        }

        log "Initializing MCP Server Documentation Extraction"

        # Build the mcp-server-dump command arguments using array for safety
        declare -a CMD_ARGS=()

        # Add transport if specified
        if [ -n "${{ inputs.transport }}" ] && [ "${{ inputs.transport }}" != "stdio" ]; then
            CMD_ARGS+=("-t" "${{ inputs.transport }}")
        fi

        # Add endpoint if specified
        if [ -n "${{ inputs.endpoint }}" ]; then
            CMD_ARGS+=("--endpoint" "${{ inputs.endpoint }}")
        fi

        # Add headers if specified
        if [ -n "${{ inputs.headers }}" ]; then
            parse_comma_separated_values "${{ inputs.headers }}" "header"
            for header in "${PARSED_ITEMS[@]}"; do
                CMD_ARGS+=("-H" "$header")
            done
        fi

        # Add format if not default
        if [ "${{ inputs.format }}" != "markdown" ]; then
            CMD_ARGS+=("-f" "${{ inputs.format }}")
        fi

        # Add output file if specified
        if [ -n "${{ inputs.output-file }}" ]; then
            CMD_ARGS+=("-o" "${{ inputs.output-file }}")
            OUTPUT_FILE="${{ inputs.output-file }}"
        else
            # Generate default output filename based on format
            case "${{ inputs.format }}" in
                "html")
                    OUTPUT_FILE="mcp-server-dump.html"
                    CMD_ARGS+=("-o" "$OUTPUT_FILE")
                    ;;
                "json")
                    OUTPUT_FILE="mcp-server-dump.json"
                    CMD_ARGS+=("-o" "$OUTPUT_FILE")
                    ;;
                "pdf")
                    error_exit "PDF format requires output-file to be specified"
                    ;;
                *)
                    OUTPUT_FILE="mcp-server-dump.md"
                    CMD_ARGS+=("-o" "$OUTPUT_FILE")
                    ;;
            esac
        fi

        # Add no-toc flag if specified
        if [ "${{ inputs.no-toc }}" = "true" ]; then
            CMD_ARGS+=("--no-toc")
        fi

        # Add frontmatter if specified
        if [ -n "${{ inputs.frontmatter }}" ]; then
            CMD_ARGS+=("--frontmatter" "${{ inputs.frontmatter }}")
        fi

        # Add timeout if not default
        if [ "${{ inputs.timeout }}" != "30" ]; then
            CMD_ARGS+=("--timeout" "${{ inputs.timeout }}s")
        fi

        # Add verbose flag if specified
        if [ "${{ inputs.verbose }}" = "true" ]; then
            CMD_ARGS+=("-v")
        fi

        # Add context files if specified
        if [ -n "${{ inputs.context-files }}" ]; then
            parse_comma_separated_values "${{ inputs.context-files }}" "context file" "validate_context_file"
            for context_file in "${PARSED_ITEMS[@]}"; do
                CMD_ARGS+=("--context-file" "$context_file")
            done
        fi

        # Add server command (this should be the last argument)
        if [ -n "${{ inputs.server-command }}" ]; then
            # Split server command into separate arguments for proper handling
            read -ra SERVER_CMD <<< "${{ inputs.server-command }}"
            CMD_ARGS+=("${SERVER_CMD[@]}")
        fi

        # Build complete docker command array
        declare -a DOCKER_CMD_ARRAY=(
            "docker" "run" "--rm"
            "-v" "$PWD:/workspace" "-w" "/workspace"
            "ghcr.io/spandigital/mcp-server-dump:latest"
        )

        # Combine with mcp-server-dump arguments
        FULL_CMD_ARRAY=("${DOCKER_CMD_ARRAY[@]}" "${CMD_ARGS[@]}")

        log "Executing MCP Server Dump: docker run --rm -v \"$PWD:/workspace\" -w /workspace ghcr.io/spandigital/mcp-server-dump:latest ${CMD_ARGS[*]}"

        # Execute the command using array expansion for safety
        if "${FULL_CMD_ARRAY[@]}"; then
            log "Success: MCP Server documentation extraction completed"

            # Set outputs
            set_output "output-file" "$OUTPUT_FILE"

            # If the output file exists, try to extract server info for the output
            if [ -f "$OUTPUT_FILE" ] && [ "${{ inputs.format }}" = "json" ]; then
                SERVER_INFO=$(cat "$OUTPUT_FILE")
                set_output "server-info" "$SERVER_INFO"
                log "Output: Generated ${{ inputs.format }} documentation with server metadata at '$OUTPUT_FILE'"
            elif [ -f "$OUTPUT_FILE" ]; then
                # For non-JSON formats, create a simple server info
                SERVER_INFO="{\"output_file\":\"$OUTPUT_FILE\",\"format\":\"${{ inputs.format }}\"}"
                set_output "server-info" "$SERVER_INFO"
                log "Output: Generated ${{ inputs.format }} documentation at '$OUTPUT_FILE'"
            fi
        else
            error_exit "Failed: MCP Server documentation extraction encountered an error"
        fi